#### 一、2种实现多线程的方法
 - 继承Thread重写run函数
 - 实现Runnable重写run函数

#### 二、如何中断一个线程和如何停止一个不能响应中断的线程（一个线程处于IO阻塞状态，是不能响应中断的，那么我们怎么能让它响应中断呢？）（注意：interrupted() 函数所返回的线程中断状态是当前执行这个函数的线程的，而不是某个对象线程的（也就是：interrupted() == Thread.interrupted()），所有判断线程是否被中断推荐使用 isInterrupted()函数）
 - 线程中断可使用interrupt()函数（注意：interrupt()函数实际上是一个和线程交互的动作（就是线程里面不断使用isInterrupted()函数，判断外面是否有调用interrupt()函数中断线程）。处于IO阻塞状态的线程是不能使用interrupt()函数来中断的，因为阻塞了的线程，它里面的代码不能执行了，那么判断线程中断的函数isInterrupted()也是不能执行了的））
 - 如果使用的是 Lock 锁，比如 ReentrantLock，可以使用 lockInterruptibly() 函数打断线程
 - 如果一个线程处于IO阻塞状态，我们可使用catch InterruptedException（线程被打断的异常），来处线程中断
 - run函数里面带有sleep或wait函数时并且在循环里面catch线程中断的错误（注意：如果监听到了InterruptedException错误，那么isInterrupted()将会失效，因为发生InterruptedException错误时，线程就会把interrupted标记还原。所以如果是在循环里面处理线程中断，建议在catch到错误的里面再次调用interrupt()函数来中断线程）
 - 不建议使用 volatile 关键字定义一个变量用来标识线程是否需要停止，因为如果线程在循环里面处于阻塞状态，虽然标识线程是否停止的变量改了，但线程还是处于阻塞状态，无法停止。直到线程解除阻塞状态，才会停止
 
#### 三、线程的六种状态
 - New（已创建但没有启动）
 - Runnable（调用start()函数后，状态就会从New变成Runnable可运行状态）
 - Blocked（当一个线程进入一个被synchronized关键字修饰的代码块并且没有获取到锁时，线程就会进入Blocked等待状态）
 - Waiting（当一个线程里面使用Object.wait()阻塞时，线程就会进入Waiting等待状态）
 - Timed Waiting（当一个线程里面使用Thread.sleep()函数进行休眠时，线程就会进入Timed Waiting状态）
 - Terminated（线程以终止）
 
#### 四、线程比较重要的几个函数（注意：wait(),notify(),notifyAll()定义在Object里面是因为这个三个都需要锁，都是和锁相关的）
 - wait() 函数使线程进入等待状态（注意：wait()函数释放掉锁，而且一定要在synchronized代码块内使用）
 - notify() 函数唤醒使用wait()函数等待的线程（注意：notify()函数一定要在synchronized代码块内使用）
 - notifyAll() 函数唤醒所有使用wait()函数等待的线程（注意：多个线程虽然都被唤醒但要获取到锁才能执行，notifyAll()函数一定要在synchronized代码块内使用）
 - sleep() 函数使线程等待有限时间（注意：sleep()函数不会释放锁，它在睡觉的时候，也是抱着锁不放的）
 - join() 函数的作用就是等该线程（调用join()函数的线程）执行完毕后才继续执行当前线程（注意：join()函数实际上是使用wait()进行等待的，而唤醒是由JVM来做的，因为JVM在线程执行完成后，都会执行一个唤醒join的操作）
 - yield() 函数的作用就是让出CUP（就是线程里面调用了yield()函数，该线程可能会处于等待执行（只是等待不会改变线程状态）。（注意：只是示意愿意让出CPU使用权,但是不是一定会让出(取决于线程调度器)，无论线程调度器是否接受这个示意,都不会改变锁的所有权））
 
#### 五、线程相关属性
 - 新建线程默认继承父线程的相关属性（比如线程类别是用户线程还是守护线程）
 - 优先级别有10个等级，设置优先级使用setPriority()函数。默认新创建的线程的优先级别是5
 - 不建议设置线程优先级（因为每个操作系统的线程优先级的等级是不一样的，还有设置了优先级的线程将不可控）
 
#### 六、线程未捕获异常的处理方式（线程未捕获异常是指：在线程里面发生了异常而我们代码里面并没有使用try catch去捕获） 
 - 建议使用Thread.setUncaughtExceptionHandler()函数设置一个未捕获异常的处理器（使用方法可查看 T_07_UncaugException.java）
 - 未捕获异常处理器的调用策略是首先检查父线程是否有设置未捕获异常处理器，如果有直接使用，它是向上查找的（所以建议在main函数线程里面设置一个未捕获异常处理器）
 
#### 七、线程上下文切换相关（补充：当线程数超过CPU的数量的时候，线程将被调度，以保证每个线程都有机会运行）
 - 线程上下文指的是线程的状态和它相关的信息，当前线程被挂起时候，线程的相关信息将会被存储在内存里面，这些信息就是上下文
 - 上下文切换是指当一个线程被挂起，另一个线程被唤醒的时候就是一次上下文切换
 - 为什么上下文件切换比较耗资源是因为正在执行的线程的相关数据会在CUP的寄存器里面缓存，但切换到另一个线程的时候，这些寄存器里面的数据会被清除，用来存储另一个线程的相关数据。而这个数据切换是耗CPU资源的
 
#### 八、产生死锁的相关原因（注意：产生死锁的根本原因还是环路问题，就是多线程获同时取锁的顺序最后形成了一个环路。所以只要避免环路问题就可以解决死锁问）
 - 发生死锁的必要条件（1 多把锁，2 多个线程，3 嵌套锁且每个线程获取锁的顺序不一样，最后造成环路（线程1先获取锁A再获取锁B，线程2先获取锁B再获取锁A），4 等待锁（要等待锁完成））
 - 哲学家就餐问题（先拿到左边的筷子再拿拿到右边的筷子才能吃饭）（环路死锁：三个线程同时执行：线程一先获取锁 A，再获取锁B；线程二先获取锁B，再获取锁C；线程三先获取锁C再获取锁A） ，演示代码：T_15_DiningPhilosophers.class
 
#### 九、解决死锁的相关方案（注意：解决死锁的根本方案就是让环路不要形成就不会有死锁，如果生产环境发生了死锁，我们将堆栈信息导出来用工具分析，比如 jstack，看在那个位置发生了死锁）
 - 转账换序方案（就是无论是谁给谁转账，它们获取锁的顺序都是一样的，就可以解决死锁了。演示代码在 T_14_Lock_Deadlock.class）
 - 哲学家就餐（避免策略：就是要拿筷子找同一个人，而这个人知道你能拿到这根筷子）
 - 哲学家就餐（改变一个哲学家拿筷子的顺序策略：就是一般都是先拿左边再拿右边，如果有一个哲学家是先拿右边再拿左边，就不会造成环路问题，就不会造成死锁），演示代码：T_16_DiningPhilosophers.class
 - 哲学家就餐（只能有（哲学家数 - 1）个哲学家可以同时吃饭，这样就不会造成环路，就不会造成死锁）
 - 检测与恢复策略（一段时间检测到有死锁，就剥夺某一个资源，来释放资源打开死锁） 
 - 如果发生死锁的概率极低，我们就直接忽略它，如果发生了人工修复 
 - 生产环境可以使用获取锁的超时时间来解决死锁发生，演示代码：T_17_TryLockDeadlock.class（注意：如果超时时间是相同的，就不推荐使用，因为相同的超时时间可能发生活锁，所以不是很推荐使用）
 - 使用同步代码块降低锁的粒度来避免死锁问题
 - 使用concurrent包下的原子类来避免死锁问题
 
#### 十、使用jstack命令查找死锁信息（可启动 T_12_Lock_Deadlock.class 代码，来演示查找死锁）
```bash
# 先找到发生死锁程序的pid
$ jps         

# 查找pid为644的程序发生死锁的情况（翻到最后可看到死锁的个数，例如：Found 1 deadlock）
$ jstack 644  
```

#### 十一、使用代码来查找死锁信息（具体演示代码：T_13_Lock_Deadlock.class）
```bash
# 获取线程栈信息
ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
# 获取发生死锁的线程id数组
long[] findMonitorDeadlockedThreads = threadMXBean.findMonitorDeadlockedThreads();
for(int i=0;i<findMonitorDeadlockedThreads.length;i++) {
	ThreadInfo threadInfo = threadMXBean.getThreadInfo(findMonitorDeadlockedThreads[i]);
	System.out.println("发生死锁了，线程是："+threadInfo.getThreadName());
}
```

#### 十二、活锁相关（什么是活锁：就是线程没有阻塞，但是没有执行我们的代码逻辑。比如哲学家就餐问题，它是先拿左边的筷子，再拿右的筷子，如果我们使用获取筷子的超时时间且超时时间是相同的方案来解决死锁问题，就有可能产生活锁，比如哲学家都同时拿起左边的筷子等待右的筷子，超时后又同时拿起左边的筷子等待右边的筷子，循环往复，什么也干不了，这就是活锁。要解决这个办法只要超时时间不要相同就可以了）
 - 演示活锁代码：T_18_LiveLock.class
 - 使用增加随机因素来解决活锁问题，演示代码：T_19_LiveLock.class
